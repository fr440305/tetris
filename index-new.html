<!doctype html>
<html>
<head>
<meta charset="utf8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<style>
body { font-family: sans-serif; }
/*# bootstrap-style classes: */
.container      { display: flex; flex-direction: column; }
.row            { display: flex; flex-direction: row;    }
.align-center   { align-items    : center; }
.justify-center { justify-content: center; }
.btn { border-radius: 5px; background: black; color: white; padding: 8px;}
/*# game-spec: */
#app > .row {
	justify-content: center;
}
#playfield > .row > div {
	margin : 0;
	padding: 0;
	width : 18px;
	height: 18px;
}
#next_tetrimino_grid > .row > div {
	margin : 0;
	padding: 0;
	width : 8px;
	height: 8px;
}
.overlay {
	position: absolute;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
	margin: 0;
	background: rgba(0, 0, 0, 0.25);
}
.overlay {
	z-index: 10;
}
.overlay .btn {
	z-index: 100;
}
#playfield {
	margin-right: 10px;
	border-radius: 5px;
	border: 1px solid;
}
/*# init */
.overlay {
	display: none;
}
/*# debug: */
div { /* border: 1px solid;*/ }
</style>
</head>
<body>
<div id="pause_overlay" class="overlay container align-center">
	<div class="row">
		<div class="col btn" id="btn_resume">Resume</div>
	</div>
</div>
<div id="game_over_overlay" class="overlay container align-center justify-center">
	<div class="row">
		<div class="col btn" id="btn_restart">Restart</div>
	</div>
</div>
<div id="app" class="container align-center ">
	<div class="row justify-center ">
		<div class="col">
			<h2>- T E T R I S -</h2>
		</div>
	</div>
	<div class="row justify-center">
		<div class="col">
			<div id="playfield" class="container">
				<div class="row"> <div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div> </div>
				<div class="row"> <div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div> </div>
				<div class="row"> <div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div> </div>
				<div class="row"> <div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div> </div>
				<div class="row"> <div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div> </div>
				<div class="row"> <div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div> </div>
				<div class="row"> <div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div> </div>
				<div class="row"> <div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div> </div>
				<div class="row"> <div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div> </div>
				<div class="row"> <div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div> </div>
				<div class="row"> <div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div> </div>
				<div class="row"> <div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div> </div>
				<div class="row"> <div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div> </div>
				<div class="row"> <div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div> </div>
				<div class="row"> <div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div> </div>
				<div class="row"> <div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div> </div>
				<div class="row"> <div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div> </div>
				<div class="row"> <div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div> </div>
				<div class="row"> <div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div> </div>
				<div class="row"> <div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div> </div>
			</div>
		</div>
		<div class="col">
			<div class="container side-bar">
				<div class="row">
					<div class="col">
						<div class="next-tetrimino-panel container">
							<div class="row">Upcoming</div>
							<div class="row justify-center">
								<div class="col">
									<div id="next_tetrimino_grid" class="container">
										<div class="row"> <div></div><div></div><div></div><div></div> </div>
										<div class="row"> <div></div><div></div><div></div><div></div> </div>
										<div class="row"> <div></div><div></div><div></div><div></div> </div>
										<div class="row"> <div></div><div></div><div></div><div></div> </div>
									</div>
								</div>
							</div>
						</div>
					</div>
				</div>
				<div class="row">
					<div class="col">
						<div class="player-score">Score: <span id="player_score_text"></span></div>
					</div>
				</div>
				<div class="row">
					<div class="col">
						<div class="btn" id="btn_pause">Pause</div>
					</div>
				</div>
			</div>
		</div>
	</div>
</div>
<pre><code id="debug_input"></code></pre>
<pre><code id="debug_state"></code></pre>
<script>

//# input

function createInputManager() {
	var userInput = ({
		eventQueue: [],
		keyboard: {
			// key of interests:
			' ': false,
			'W': false, 'A': false, 'S': false, 'D': false,
			'H': false, 'J': false, 'K': false, 'L': false
		},
		touch: {
			isTouching: false,
			x: 0,
			y: 0,
			startX: 0,
			startY: 0,
			startSince: 0,
		}
	});
	addEventListeners(userInput);
	return userInput;
};

function addEventListeners(userInput) {
	var playfieldEl = document.getElementById('playfield');
	var pauseBtn = document.getElementById('btn_pause');
	var resumeBtn = document.getElementById('btn_resume');
	var restartBtn = document.getElementById('btn_restart');
	var overlays = Array.from(document.getElementsByClassName('overlay'));
	overlays.forEach(function (e) {
		e.addEventListener('touchstart', function (e) { e.preventDefault(); });
		e.addEventListener('touchmove' , function (e) { e.preventDefault(); });
		e.addEventListener('touchend'  , function (e) { e.preventDefault(); });
	});
	document.body.addEventListener('keydown', function (e) {
		console.log(e);
		var k  = e.key.toUpperCase();
		if (userInput.keyboard.hasOwnProperty(k)) {
			e.preventDefault();
			userInput.eventQueue.push({type: 'KeyDown', data: k});
			userInput.keyboard[k] = true;
		}
	});
	document.body.addEventListener('keyup', function (e) {
		console.log(e);
		var k  = e.key.toUpperCase();
		if (userInput.keyboard.hasOwnProperty(k)) {
			e.preventDefault();
			userInput.eventQueue.push({type: 'KeyUp', data: k});
			userInput.keyboard[k] = false;
		}
	});
	playfieldEl.addEventListener('touchstart', function (e) {
		e.preventDefault();
	});
	playfieldEl.addEventListener('touchmove', function (e) {
		e.preventDefault();
	});
	playfieldEl.addEventListener('touchend', function (e) {
		e.preventDefault();
	});
	pauseBtn.addEventListener('click', function () {
		userInput.eventQueue.push({type: 'BtnClick', data: 'Pause'});
	});
	resumeBtn.addEventListener('click', function () {
		userInput.eventQueue.push({type: 'BtnClick', data: 'Resume'});
	});
	resumeBtn.addEventListener('touchstart', function () {
		userInput.eventQueue.push({type: 'BtnClick', data: 'Resume'});
	});
	restartBtn.addEventListener('click', function () {
		userInput.eventQueue.push({type: 'BtnClick', data: 'Restart'});
	});
};

//# state

function createState() {
	var state = {
		t: 0,
		world: {
			playfieldRowSize: 20,
			playfieldColSize: 10,
			score: 0,
			isPaused: false,
			isGameOver: false,
			currentTetrimino: {
				r: 0,
				c: 0,
				type: 'Z',
				matrix: Tetriminos['Z']
			},
			upcomingTetriminoTypes: [
				'I', 'O', 'T', 'S', 'Z', 'J', 'L'
			],
			lockedGrid: Array(20).fill(0).map(
				function (e) { return Array(10).fill('') }
			),  // A 20x10 2d array, with all ''.
			hasEliminableRows: false,
			isHardDropAvailable: true, // false if no position.
			hardDropDestinationRow: 0, // tbd
			eliminationWaitingTime: 500, // ms
			dropWaitingTime     :  1000, // ms
			tLastRestart : -1,
			tLastSpawned :  0,
			tLastSoftDrop: -1,
			tLastLocked  : -1,
			tLastRestart : -1,
		},
		config: {
			difficulty: 0, // will affect world.dropWaitingTime
			keyMap: {
				'W': 'hard-drop',
				'A': 'move-left',
				'S': 'move-down',
				'D': 'move-right',
				'J': 'spin-clockwise',
				'K': 'spin-counter-clockwise',
				' ': 'pause-or-restart'
			}
		},
		debug: {
		}
	};
	updateHardDropDestinationRow(state);
	return state;
};

var Tetriminos = {
	I: [
		[0, 0, 0, 0],
		[1, 1, 1, 1],
		[0, 0, 0, 0],
		[0, 0, 0, 0]
	],
	O: [
		[0, 0, 0, 0],
		[0, 1, 1, 0],
		[0, 1, 1, 0],
		[0, 0, 0, 0]
	],
	T: [
		[0, 1, 0],
		[1, 1, 1],
		[0, 0, 0]
	],
	S: [
		[0, 1, 1],
		[1, 1, 0],
		[0, 0, 0]
	],
	Z: [
		[1, 1, 0],
		[0, 1, 1],
		[0, 0, 0]
	],
	J: [
		[1, 0, 0],
		[1, 1, 1],
		[0, 0, 0]
	],
	L: [
		[0, 0, 1],
		[1, 1, 1],
		[0, 0, 0]
	]
};

var TetriminoColors = {
	I: 'cyan'  ,
	O: 'yellow',
	T: 'purple',
	S: 'green' ,
	Z: 'red'   ,
	J: 'blue'  ,
	L: 'brown' ,
};

function pauseGame(state) {
	state.world.isPaused = true;
};

function resumeGame(state) {
	state.world.isPaused = false;
};

function togglePauseState(state) {
	if (state.world.isPaused === false) {
		state.world.isPaused = true;
	} else {
		state.world.isPaused = false;
	}
};

function restartGame(state) {
	// XXX TODO(wtan 2022-03-31)
	return null;
};

function canCurrentTetriminoMoveToward(state, direction) {
	var tet = state.world.currentTetrimino;
	// Offsets:
	var nextOffR = tet.r + direction.r;
	var nextOffC = tet.c + direction.c;
	var translatedR;
	var translatedC;
	var r;
	var c;
	for (r = 0; r < tet.matrix.length; r++) {
		for (c = 0; c < tet.matrix[r].length; c++) {
			if (tet.matrix[r][c] === 1) {
				translatedR = nextOffR + r;
				translatedC = nextOffC + c;
				// Check if translated{R, C} overlaped or overbound:
				if (
					translatedR < 0 || translatedR >= state.world.playfieldRowSize ||
					translatedC < 0 || translatedC >= state.world.playfieldColSize
				) {
					// Overbound!
					return false;
				} else if (state.world.lockedGrid[translatedR][translatedC] !== '') {
					// Overlap!
					return false;
				}
			}
		}
	}
	return true;
};

function moveCurrentTetriminoToward(state, direction) {
	state.world.currentTetrimino.r += direction.r;
	state.world.currentTetrimino.c += direction.c;
};

function updateHardDropDestinationRow(state) {
	// Don't have to consider the case when hard drop position is
	// not available. Because it only time it would happened is that
	// the game is over.
	var r;
	var tet = state.world.currentTetrimino;
	var rowSize = state.world.playfieldRowSize;
	for (r = 0; r < rowSize; r++) {
		if (!canCurrentTetriminoMoveToward(state, {r: r+1, c: 0})) {
			break;
		}
	}
	console.log('updateHardDropDestinationRow(): ' + r);
	state.world.hardDropDestinationRow = tet.r + r;
};

function hardDropCurrentTetrimino(state) {
	if (state.world.isHardDropAvailable) {
		state.world.currentTetrimino.r = (
			state.world.hardDropDestinationRow
		);
	}
};

function lockCurrentTetrimino(state) {
	var tet = state.world.currentTetrimino;
	var r;
	var c;
	for (r = 0; r < tet.matrix.length; r++) {
		for (c = 0; c < tet.matrix[r].length; c++) {
			if (tet.matrix[r][c] === 1) {
				state.world.lockedGrid[tet.r+r][tet.c+c] = tet.type;
			}
		}
	}
	state.world.hasEliminableRows = hasEliminableRows(state);
	state.world.tLastLocked = state.t;
}

function canCurrentTetriminoSpinToward(state, isClockwise) {
	var tet = state.world.currentTetrimino;
	var len = (tet.type === 'I' || tet.type === 'O') ? 4 : 3;
	var nextMatrix = Array(len).fill(0).map(function (e) { return Array(len).fill(0) });
	var r;
	var c;
	var translatedR;
	var translatedC;
	if (isClockwise) {
		for (r = 0; r < len; r++) {
			for (c = 0; c < len; c++) {
				nextMatrix[r][c] = tet.matrix[len-1-c][r];
			}
		}
	} else {
		for (r = 0; r < len; r++) {
			for (c = 0; c < len; c++) {
				nextMatrix[r][c] = tet.matrix[c][len-1-r];
			}
		}
	}
	for (r = 0; r < len; r++) {
		for (c = 0; c < len; c++) {
			if (nextMatrix[r][c] === 1) {
				translatedR = tet.r + r;
				translatedC = tet.c + c;
				if (
					translatedR < 0 || translatedR >= state.world.playfieldRowSize ||
					translatedC < 0 || translatedC >= state.world.playfieldColSize
				) {
					// Overbound:
					return false;
				} else if (state.world.lockedGrid[translatedR][translatedC] !== '') {
					// Overlap:
					return false;
				}
			}
		}
	}
	return true;
};

function spinCurrentTetriminoToward(state, isClockwise) {
	var tet = state.world.currentTetrimino;
	var len = (tet.type === 'I' || tet.type === 'O') ? 4 : 3;
	var nextMatrix = Array(len).fill(0).map(
		function (e) { return Array(len).fill(0) }
	);
	var r;
	var c;
	if (isClockwise) {
		for (r = 0; r < len; r++) {
			for (c = 0; c < len; c++) {
				nextMatrix[r][c] = tet.matrix[len-1-c][r];
			}
		}
	} else {
		for (r = 0; r < len; r++) {
			for (c = 0; c < len; c++) {
				nextMatrix[r][c] = tet.matrix[c][len-1-r];
			}
		}
	}
	tet.matrix = nextMatrix;
};

function hasEliminableRows(state) {
	var grid    = state.world.lockedGrid;
	var rowSize = state.world.playfieldRowSize;
	var colSize = state.world.playfieldColSize;
	var r;
	var c;
	var shouldEliminate = true;
	for (r = 0; r < rowSize; r++) {
		shouldEliminate = true;
		for (c = 0; c < colSize; c++) {
			if (grid[r][c] === '') {
				shouldEliminate = false;
				break;
			}
		}
		if (shouldEliminate) {
			return true;
		}
	}
	return false;
}

function getIndexesOfEliminableRows(state) {
	var ret = [];
	var grid = state.world.lockedGrid;
	var rowSize = state.world.playfieldRowSize;
	var colSize = state.world.playfieldColSize;
	var shouldEliminate = true;
	var r;
	var c;
	for (r = 0; r < rowSize; r++) {
		shouldEliminate = true;
		for (c = 0; c < colSize; c++) {
			if (grid[r][c] === '') {
				shouldEliminate = false;
				break;
			}
		}
		if (shouldEliminate) {
			ret.push(r);
		}
	}
	return ret;
};

function calculateEliminationScore(state) {
	var indexes = getIndexesOfEliminableRows(state);
	var i;
	var j;
	var tmp;
	var bonus = 0;
	// Sort from smaller index to larger index:
	for (i = 0; i < indexes.length; i++) {
		for (j = 0; j < indexes.length; j++) {
			if (indexes[i] > indexes[j]) {
				tmp = indexes[i];
				indexes[i] = indexes[j];
				indexes[j] = tmp;
			}
		}
	}
	// Calculate bonus due to continuation:
	if (indexes.length === 4) {
		bonus = 400;
	} else {
		for (i = 1; i < indexes.length; i++) {
			if (indexes[i-1] + 1 === indexes[i]) {
				bonus += 100;
			}
		}
	}
	return 100 * indexes.length + bonus;
};

function eliminateRowsInLockedGrid(state) {
	var indexes = getIndexesOfEliminableRows(state);
	var indexSet = new Set(indexes);
	var newLockedGrid = [];
	var rowSize = state.world.playfieldRowSize;
	var r;
	console.log(indexes.length);
	for (r = 0; r < indexes.length; r++) {
		console.log(r);
		newLockedGrid.push(Array(10).fill(''));
	}
	for (r = 0; r < rowSize; r++) {
		if (!indexSet.has(r)) {
			console.log(r);
			newLockedGrid.push(state.world.lockedGrid[r]);
		}
	}
	console.log(newLockedGrid);
	state.world.lockedGrid = newLockedGrid;
}

function canSpawnTetrimino(state) {
	var nextType = state.world.upcomingTetriminoTypes[0];
	var matrix = Tetriminos[nextType];
	var offR = 0;
	var offC = 3;
	var r;
	var c;
	for (r = 0; r < matrix.length; r++) {
		for (c = 0; c < matrix[r].length; c++) {
			if (matrix[r][c] === 1) {
				if (state.world.lockedGrid[offR + r][offC + c] !== '') {
					return false;
				}
			}
		}
	}
	return true;
};

function spawnTetrimino(state) {
	var nextTetriminoType = (
		state.world.upcomingTetriminoTypes.shift()
	);
	var sequence = ['I', 'O', 'T', 'S', 'Z', 'J', 'L'];
	var tet = state.world.currentTetrimino;
	var i;
	var j;
	var tmp;
	// Spawn:
	tet.type = nextTetriminoType;
	tet.matrix = Tetriminos[nextTetriminoType];
	tet.r = 0;
	tet.c = 3;
	// Prepare for next use:
	if (state.world.upcomingTetriminoTypes.length === 0) {
		for (i = 0; i < sequence.length; i++) {
			for (j = 0; j < i; j++) {
				if (Math.random() > 0.5) {
					tmp         = sequence[i];
					sequence[i] = sequence[j];
					sequence[j] = tmp;
				}
			}
		}
		state.world.upcomingTetriminoTypes = sequence;
	}
	state.world.tLastSpawned = state.t;
}

function updateState(state, input, t) {
	var dtSoftDrop = state.world.dropWaitingTime;
	var leftDirection  = {r: 0, c: -1}
	var rightDirection = {r: 0, c:  1}
	var downDirection  = {r: 1, c:  0}; // default: down
	// Determine current state:
	var isFalling = (
		t > state.world.tLastSpawned &&
		state.world.tLastSpawned > state.world.tLastLocked
	);
	var isLockedButNotSpawnedYet = (
		t > state.world.tLastLocked &&
		state.world.tLastLocked > state.world.tLastSpawned
	);
	var canChangeCurrentTetrimino = (
		// XXX
		isFalling &&
		!state.world.isPaused &&
		!state.world.isGameOver
	);
	var inputEvent;
	var operation;
	// Read user input and update tet position:
	while (input.eventQueue.length !== 0) {
		inputEvent = input.eventQueue.shift();
		console.log('updateState(): inputEvent: ' + JSON.stringify(inputEvent));
		if (inputEvent.type === 'KeyDown') {
			operation = state.config.keyMap[inputEvent.data];
			if (operation === 'pause-or-restart') {
				console.log('updateState(): pause!');
				if (state.world.isGameOver === false) {
					togglePauseState(state);
				}
			} else if (operation === 'move-left') {
				if (canChangeCurrentTetrimino) {
					if (canCurrentTetriminoMoveToward(state, leftDirection)) {
						moveCurrentTetriminoToward(state, leftDirection);
						updateHardDropDestinationRow(state);
					}
				}
			} else if (operation === 'move-right') {
				if (canChangeCurrentTetrimino) {
					if (canCurrentTetriminoMoveToward(state, rightDirection)) {
						moveCurrentTetriminoToward(state, rightDirection);
						updateHardDropDestinationRow(state);
					}
				}
			} else if (operation === 'move-down') {
				if (canChangeCurrentTetrimino) {
					if (canCurrentTetriminoMoveToward(state, downDirection)) {
						moveCurrentTetriminoToward(state, downDirection);
					}
				}
			} else if (operation === 'hard-drop') {
				if (canChangeCurrentTetrimino) {
					hardDropCurrentTetrimino(state);
					lockCurrentTetrimino(state); // lock immediately
				}
			} else if (operation === 'spin-clockwise') {
				if (canCurrentTetriminoSpinToward(state, true)) {
					spinCurrentTetriminoToward(state, true);
					updateHardDropDestinationRow(state);
				}
			} else if (operation === 'spin-counter-clockwise') {
				if (canCurrentTetriminoSpinToward(state, false)) {
					spinCurrentTetriminoToward(state, false);
					updateHardDropDestinationRow(state);
				}
			}
		} else if (inputEvent.type === 'BtnClick') {
			if (inputEvent.data === 'Pause') {
				console.log('updateState(): pause?!');
				pauseGame(state);
				console.log('updateState(): pause: ' + state.world.isPaused);
			} else if (inputEvent.data === 'Resume') {
				resumeGame(state);
			} else if (inputEvent.data === 'Restart') {
				// ...
			}
		}
	}
	if (canChangeCurrentTetrimino) {
		// Soft drop:
		if (t - state.world.tLastSoftDrop > dtSoftDrop) {
			if (canCurrentTetriminoMoveToward(state, downDirection)) {
				moveCurrentTetriminoToward(state, downDirection);
				state.world.tLastSoftDrop = t;
			} else {
				// fallen:
				lockCurrentTetrimino(state);
			}
		}
	} else if (isLockedButNotSpawnedYet) {
		if (state.world.hasEliminableRows) {
			if (t - state.world.tLastLocked > state.world.eliminationWaitingTime) {
				state.world.score += calculateEliminationScore(state);
				eliminateRowsInLockedGrid(state);
				state.world.hasEliminableRows = false;
			}
		} else {
			if (canSpawnTetrimino(state)) {
				spawnTetrimino(state);
				updateHardDropDestinationRow(state);
			} else {
				// Cannot spawn => Game over!
				state.world.isGameOver = true;
			}
		}
	} else {
		// ... ???
	}

	state.t = t;
};

//# rendering

function createRenderMemo() {
	var memo = {
		el: {
			playfield: (
				Array
					.from(document.querySelector('#playfield').children)
					.map(function (e) { return Array.from(e.children) })
			),
			nextTetriminoGrid: (
				Array
					.from(document.querySelector('#next_tetrimino_grid').children)
					.map(function (e) { return Array.from(e.children) })
			),
			pauseOverlay     : document.querySelector('#pause_overlay'),
			restartOverlay   : document.querySelector('#game_over_overlay'),
			score            : document.querySelector('#player_score_text'),
			btnPauseOrRestart: document.querySelector('#btn_pause')
		},
		//prevPlayfield: [],  // Optimization
		//currentPlayfield: [],
	};
	console.log(memo.el.playfield);
	return memo;
};

function renderState(state, memo, t) {
	var tet = state.world.currentTetrimino;
	var nextType = state.world.upcomingTetriminoTypes[0];
	var nextMatrix = Tetriminos[nextType];
	var r;
	var c;
	// Paused?
	if (state.world.isPaused === true) {
		memo.el.pauseOverlay.style.display = 'block';
		return;
	} else {
		memo.el.pauseOverlay.style.display = 'none';
	}
	// Game Over?
	if (state.world.isGameOver === true) {
		memo.el.restartOverlay.style.display = 'block';
		return;
	} else {
		memo.el.restartOverlay.style.display = 'none';
	}
	// Clean the playfield:
	for (r = 0; r < state.world.playfieldRowSize; r++) {
		for (c = 0; c < state.world.playfieldColSize; c++) {
			memo.el.playfield[r][c].style.background = 'white';
		}
	}
	// Clean the next display:
	for (r = 0; r < 4; r++) {
		for (c = 0; c < 4; c++) {
			memo.el.nextTetriminoGrid[r][c].style.background = 'white';
		}
	}
	// Draw hard drop hint:
	for (r = 0; r < tet.matrix.length; r++) {
		for (c = 0; c < tet.matrix[r].length; c++) {
			if (tet.matrix[r][c] !== 0) {
				memo.el.playfield[state.world.hardDropDestinationRow + r][tet.c + c].style.background = 'grey';
			}
		}
	}
	// Draw current tetrimino:
	for (r = 0; r < tet.matrix.length; r++) {
		for (c = 0; c < tet.matrix[r].length; c++) {
			if (tet.matrix[r][c] === 1) {
				memo.el.playfield[tet.r + r][tet.c + c].style.background = TetriminoColors[tet.type];
			}
		}
	}
	// Draw previous tetriminos:
	for (r = 0; r < state.world.playfieldRowSize; r++) {
		for (c = 0; c < state.world.playfieldColSize; c++) {
			if (state.world.lockedGrid[r][c] !== '') {
				memo.el.playfield[r][c].style.background = TetriminoColors[state.world.lockedGrid[r][c]];
			}
		}
	}
	// Draw upcoming tetrimino:
	if (nextMatrix === undefined) {
		// err:
		// XXX (fr44 2022-04-01)
		// Under what circumstances will the control flow enter
		// this branch?
		console.log('err: renderState(): upcomingTetriminoMatrix undefined');
	} else {
		for (r = 0; r < nextMatrix.length; r++) {
			for (c = 0; c < nextMatrix[r].length; c++) {
				if (nextMatrix[r][c] === 1) {
					memo.el.nextTetriminoGrid[r][c].style.background = TetriminoColors[nextType];
				}
			}
		}
	}
	// Display score:
	memo.el.score.textContent = state.world.score;
};

//# main

(function () {
	var inputManager = createInputManager();
	var gameState    = createState();
	var renderMemo   = createRenderMemo();
	var debugInput   = document.getElementById('debug_input');
	var debugState   = document.getElementById('debug_state');
	var loop = function (t) {
		updateState(gameState, inputManager, t);
		renderState(gameState, renderMemo  , t);
		debugInput.textContent = JSON.stringify(inputManager);
		debugState.textContent = JSON.stringify(gameState);
		window.requestAnimationFrame(loop);
	};
	loop(0);
})();

</script>
</body>
</html>
